<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Board</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body>
    
    <!-- Hidden input element for file selection -->
    <div class="load-file-div">        
        <button id="loadFileToggle">-</button>
        <div class="content">                
            <!-- Button to open filePicker -->
            <button class="file-button" onclick="tileInput.openFilePicker()"><i class="fa fa-file"></i></button>

            <!-- Text area to display file contents -->
            <textarea id="fileTextArea" rows="10" cols="50"></textarea><input type="file" id="filePicker" style="display: none">
            <button class="file-button" onclick="tileInput.getOnlineFile(document.getElementById('link1'))"><i class="fa-solid fa-globe"></i></button><input id="link1"/>
            <button class="file-button" onclick="tileInput.getOnlineFile(document.getElementById('link2'))"><i class="fa-solid fa-globe"></i></button><input id="link2"/>
        </div> 
    </div>

    <!-- Container for displaying div panels -->
    <div id="tileOutputContainer"></div>
    
    <script>
        
        /*
         **************************************************************************************************************
         ************************************************************************************************************** 
         * README - Where to begin?
         * #1 - TileInput() :
         * #2   - filePicker {{onload}} calling <<load>>
         * #3   - fileTextArea {{onblur}} calling <<load>>
         * #4   - {{page_load}} calling <<load>>
         * #5 - TileOutput <<load>> is iterating over each individual line of text from input
         * #6   - An identation level is set and TileOutput <<append>> is called to add each Tile to dom
         **************************************************************************************************************
         **************************************************************************************************************
        */        
                
        const tileInput =  new TileInput();
        const tileOutput = new TileOutput();
        tileOutput.load(tileInput.fileTextArea.value);
        function TileInput() { 
            const self = this;     
            const loadFileToggle = CreateToggleButton('loadFileToggle');
            const filePicker = document.getElementById('filePicker');
            filePicker.onchange = (event) => {                     
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function (e) {                             
                        fileTextArea.value = e.target.result;
                        tileOutput.load(fileTextArea.value);                                     
                    };
                    reader.readAsText(file);                        
                }                    
            }

            const fileTextArea = document.getElementById('fileTextArea');
            fileTextArea.addEventListener('blur', 
                (event) => {
                    tileOutput.load(fileTextArea.value); 
                }
            )            
            
            var collapse = () => {
                if (!loadFileToggle.nextElementSibling.classList.contains('collapsed')){                    
                    loadFileToggle.textContent = '+'; 
                    loadFileToggle.nextElementSibling.classList.add('collapsed');
                }                
            }
            var getOnlineFile = async (onlineFileUrl) => {            
                try {
                    const response = await fetch(onlineFileUrl);
                    if (response.ok) {
                        tileOutput.load(await response.text());
                    } else {
                        alert("Error loading content:", response.status);
                    }
                } catch (error) {
                    alert("Error fetching data:", error);
                }        
            }
            var openFilePicker = () => {
                filePicker.click();
            }     
            return { collapse: collapse, openFilePicker: openFilePicker, fileTextArea: fileTextArea, getOnlineFile: getOnlineFile };
        }
        function TileOutput(){            
            const element = document.getElementById('tileOutputContainer');
            const coords = { holdingX: 0, holdingY: 65};
            const isValidUrl = urlString=> {
                try { 
                    return new URL(urlString); 
                }
                catch(e){ 
                    return null; 
                }
            }
            const extractAnyUrl = (inputString) => {                
                const lastOpenParenIndex = inputString.lastIndexOf('(');
                if (lastOpenParenIndex === -1) {
                    // No open parenthesis found
                    return null;
                }
                const matchingCloseParenIndex = inputString.indexOf(')', lastOpenParenIndex);
                if (matchingCloseParenIndex === -1) {
                    // No matching closing parenthesis found
                    return null;
                }
                // Extract the content between the parentheses
                const extractedContent = inputString.slice(lastOpenParenIndex + 1, matchingCloseParenIndex);
                return isValidUrl(extractedContent);
            } 
            const createLabel = (textContent) => {
                var validURLIfSet = extractAnyUrl(textContent);                
                if (validURLIfSet){                                       
                    ele = document.createElement('a');
                    ele.setAttribute("href", validURLIfSet.toString());
                    ele.textContent = textContent.slice(0, textContent.lastIndexOf('('));
                    
                    ele.target = '_blank';
                }
                else {
                    ele = document.createTextNode(textContent);
                }
                return ele;
            }   
            const stack = []; 
            const getLastTile = () => {
                return stack[stack.length - 1];
            }
            const setAtLevel = (tile) => {
                stack[stack.length - 1] = tile;
                return stack[stack.length - 2];
            }
            const addLevel = (tile) => {
                stack[stack.length] = tile;
            }
            const removeLevel = () => {
                stack.pop();
            }
            const load = (input) => {
                element.innerHTML = ''; // Clear existing
                addLevel({ element: element, level: 0 });
                addLevel(getLastTile());
                input.split('\n').forEach((line, index) => {
                    let trimmedLine = line.trimLeft(); // Remove leading spaces
                    const indentationLevel = (line.length - trimmedLine.length) / 2;
                    trimmedLine = trimmedLine.replace("- [ ] ", ""); 
                    if (trimmedLine.length > 0){                                                           
                        append(new Tile(
                                createLabel(trimmedLine), 
                                indentationLevel));
                        tileInput.collapse(); // only necessary ONCE, but ok to repeat!
                    }
                });                 
            }
            const append = (nextTile) => {
                nextTile.setPosition(coords);
                var lastTile = getLastTile();
                if (lastTile.level < nextTile.level) { // next tile's level is greater/deeper than last tile
                    lastTile.element = lastTile.setContent();
                    addLevel(nextTile);
                }
                else {
                    while (lastTile.level > nextTile.level) { // last tile's level is greater/deeper than next tile
                        removeLevel();
                        lastTile = getLastTile();
                    }  
                    lastTile = setAtLevel(nextTile);
                }                
                
                //alert(lastTile.element.internalTileId);
                lastTile.element.appendChild(nextTile.element);
            }            
            return { load: load };
        }
        function Tile(label, indentationLevel){                      
            const level = indentationLevel;
            const div = document.createElement('div');                       
            if (level > 0){
                div.classList.add('sub-tile'); 
            }
            else {
                div.style.height =  '500px';
                div.style.width =  '300px';                
                div.classList.add('tile');
                div.internalTileId = label.textContent.replace(" ", ""); 
                // some sub-level tasks
                const top = document.createElement('div');
                top.innerHTML = '&nbsp;';
                top.classList.add('dragging-handle');
                div.appendChild(top); 
                let isDragging = false;
                let offsetX, offsetY;
                
                top.addEventListener('mousedown', (e) => {
                    e.preventDefault();             
                    isDragging = true;                                               
                    top.style.cursor = 'grabbing';
                });
               
                document.addEventListener('mousemove', (e) => {
                    if (isDragging) {
                        const newX = e.clientX;
                        const newY = e.clientY;
                        div.style.left = `${newX}px`;
                        div.style.top = `${newY}px`;
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    isDragging = false;
                    top.style.cursor = 'grab';
                });
            }
            div.appendChild(label); 
            
            const element = div;
            var setContent = () => {
                var result = div;                
                if (level == 0){ 
                    div.appendChild(CreateToggleButton());  
                    const divSubPanel = document.createElement('div');
                    divSubPanel.internalTileId = div.internalTileId;
                    divSubPanel.classList.add('content');
                    divSubPanel.classList.add('collapsed');
                    div.appendChild(divSubPanel);                     
                    result = divSubPanel;
                }                
                return result;
            }
            var setPosition = (coords) => {
                if (level == 0){
                    div.style.left = `${coords.holdingX}px`;
                    div.style.top = `${coords.holdingY}px`;
                    if ((coords.holdingX + 450) < window.innerWidth){
                        coords.holdingX += 150;
                    }
                    else {
                        coords.holdingX = 0;
                        coords.holdingY += 50;
                    }
                }
            }
            return { setContent: setContent, setPosition: setPosition, element: element, level: level }
        } 
        function CreateToggleButton(id) {            
            var element = null;
            if (id){
                element = document.getElementById(id);
            }            
            else {                
                element = document.createElement('button');
                element.style.float = 'left'; 
                element.textContent = '+'; 
            }                       

            element.addEventListener('click', () => {                 
                const allContentBlocks = document.querySelectorAll(".content"); 
                const isExpanding = element.textContent == '+'; 
                allContentBlocks.forEach((block) => {
                    if (!block.classList.contains('collapsed')){
                        block.previousElementSibling.textContent = '+';                         
                        block.classList.add('collapsed'); // hide content
                        block.parentElement.style.zIndex = 0;
                    }                    
                });
                if (isExpanding){                
                    element.nextElementSibling.classList.remove('collapsed');
                    element.textContent = '-';
                    element.parentElement.style.zIndex = 1;
                }

                const theZoomedItem = document.querySelector('.zoomed'); 
                if (theZoomedItem){
                    theZoomedItem.classList.remove('zoomed');  
                }

                if (isExpanding){
                    if (element.parentElement.classList.contains('tile')){                    
                        element.parentElement.classList.add('zoomed');                                    
                    }
                }                                
            });
            return element;
        }

    </script>
    <style>
        .file-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            vertical-align: top;
        }

        /* Add an icon to the button */
        .file-button i {
            margin-right: 5px;
        }

        .load-file-div{                                    
            background-color: #f0f0f0;
            border: 1px solid #ccc;
            padding: 10px;
            margin: 5px 0; 
            position: absolute;              
        }
        
        .dragging-handle {            
            background-color: black;
            cursor: grab;
            position: relative;
            clear:both;
        }

        .zoomed {
            transform: scale(1.12);
            transform-origin: top left; /* Set the desired origin */                                 
        }
          
        /* Style the collapsible content (hidden by default) */
        .content {               
            /*background-color: #f1f1f1;*/
        }

        .collapsed {
            display: none;
        }        

        .tile {
            position:absolute;
            border: 2px solid #000;
            
            background-color: #f9f9f9;
            transition: transform 0.3s ease; 
            resize: both; /* Enable resizing cursor */
            overflow: auto; /* Show scrollbars if content overflows */
        } 

        .sub-tile {
            border: 1px solid #ccc;
            padding: 10px;
            margin: 5px 0;
            background-color: aqua;
        }         
        
    </style>
</body>
</html>
